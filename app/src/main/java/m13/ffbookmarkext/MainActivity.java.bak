package sidr97.ffbookmarkext;

import android.Manifest;
import android.app.Activity;
import android.app.DownloadManager;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.database.SQLException;
import android.net.Uri;
import android.os.Environment;
import android.os.StrictMode;
import android.support.v4.app.ActivityCompat;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.database.sqlite.*;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;
import android.widget.ToggleButton;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.sql.SQLData;
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

public class MainActivity extends AppCompatActivity {

    ListAdapter dataAdapter = null;
    ArrayList<ListAdapter> bmarkLists;
    String dbfile, dbfile_orig, extStor, dbBackupDir;
    boolean deleteAfterDl = false;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
        StrictMode.setThreadPolicy(policy);

        String[] permissions = new String[]
                {
                        Manifest.permission.WRITE_EXTERNAL_STORAGE,
                        Manifest.permission.READ_EXTERNAL_STORAGE,
                        Manifest.permission.INTERNET
                };
        List<String> listPermissionsNeeded = new ArrayList<>();
        for (String p : permissions)
        {
            if (checkSelfPermission(p) != PackageManager.PERMISSION_GRANTED)
            {
                listPermissionsNeeded.add(p);
            }
        }
        if (!listPermissionsNeeded.isEmpty())
        {
            ActivityCompat.requestPermissions(this, listPermissionsNeeded.toArray(new String[listPermissionsNeeded.size()]), 100);
        }

        //if(checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)
        //    ActivityCompat.requestPermissions(this,new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1);

        extStor = Environment.getExternalStorageDirectory() + "/FFBookmarkExt";
        dbBackupDir = extStor + "/backups";
        File f = new File(dbBackupDir);
        f.mkdirs();

        getBookmarkDB();

        bmarkLists = parseBookmarkDB();
        if(bmarkLists == null)
            return;

        ListIterator<ListAdapter> liter = bmarkLists.listIterator();
        while(liter.hasNext())
        {
            ListIterator<Bookmark> iter = liter.next().bmarkList.listIterator();
            while(iter.hasNext())
            {
                iter.next().deselect();
            }
        }


        displayListView(bmarkLists.get(bmarkLists.size()-1));
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu)
    {
        getMenuInflater().inflate(R.menu.overflow_menu,menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item)
    {
        int id = item.getItemId();
        if(id == R.id.ov_menuitem_deleteafterdl)
        {
            item.setChecked(!item.isChecked());
            deleteAfterDl = item.isChecked();
        }
        return super.onOptionsItemSelected(item);
    }

    private void getBookmarkDB()
    {
        String profileDir = "/data/data/org.mozilla.firefox_beta/files/mozilla/", browserDBPath = "NOT_FOUND";
        File f = new File(profileDir);
        String dir[] = new String[0], profileDirName = "";
        Process p = null;
        try {
            p = Runtime.getRuntime().exec("su -c ls "+profileDir+" | grep .default");
            BufferedReader reader = new BufferedReader(
                    new InputStreamReader(p.getInputStream()));

            int read;
            char[] buffer = new char[4096];
            StringBuffer output = new StringBuffer();
            while ((read = reader.read(buffer)) > 0) {
                output.append(buffer, 0, read);
            }
            reader.close();;
            profileDirName = output.toString().replace("\n","");
            Log.i("out",profileDirName);
            p.waitFor();

        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        /*
        for(String n : dir)
        {
            if(n.contains(".default") && new File(profileDir+n).isDirectory())
                browserDBPath = profileDir+n+"/browser.db";
        }*/
        dbfile_orig = profileDir+profileDirName+"/browser.db";
        if(new File(dbfile_orig).isDirectory())
            return;

        dbfile = this.getFilesDir().getAbsolutePath();
        f = new File(dbfile);
        f.mkdirs();
        dbfile += "/browser.db";

        Long tsLong = System.currentTimeMillis()/1000;
        String ts = tsLong.toString();
        String dbBackup = dbBackupDir + "/browser.db-" + ts + ".bak";


        //dbfile_orig = "/data/data/org.mozilla.firefox_beta/files/mozilla/0aekm8mk.default/browser.db";

        try {
            //
            p = Runtime.getRuntime().exec("su -c cat "+dbfile_orig+ " > " + dbfile);
            p.waitFor();
            p = Runtime.getRuntime().exec("su -c cat "+dbfile_orig+ " > " + dbBackup);
            p.waitFor();
            //p = Runtime.getRuntime().exec("su -c chmod 644 "+ browserDBPath);
            p = Runtime.getRuntime().exec("su -c chmod 666 "+ dbfile);
            p.waitFor();
            p = Runtime.getRuntime().exec("su -c chown 10257 "+ dbfile);
            p.waitFor();
            p = Runtime.getRuntime().exec("su -c chgrp 10257 "+ dbfile);
            p.waitFor();
            p = Runtime.getRuntime().exec("su -c chcon u:object_r:app_data_file:s0:c512,c768 "+ dbfile);
            p.waitFor();
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }

        /*
        Intent i = new Intent(Intent.ACTION_GET_CONTENT);
        i.addCategory(Intent.CATEGORY_OPENABLE);
        i.setType("/");
        Intent intent = Intent.createChooser(i,"Select browser.db");
        startActivityForResult(intent,666);*/
    }


    protected void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        /*
        if (resultCode != RESULT_OK) return;
        String path = "";
        if(requestCode == 666)
        {
            Uri uri = data.getData();
            dbfile_orig = uri.toString();
            dbfile = this.getFilesDir()+ "/browser3.db";

            Process p = null;
            try
            {
                p = Runtime.getRuntime().exec("su -c cat "+dbfile_orig+" > "+dbfile);
                p.waitFor();
                p = Runtime.getRuntime().exec("su -c chmod 666 "+dbfile);
                p.waitFor();
            } catch (IOException e)
            {
                e.printStackTrace();
            } catch (InterruptedException e)
            {
                e.printStackTrace();
            }

        }*/
    }

    private ArrayList<ListAdapter> parseBookmarkDB()
    {
        //dbfile = this.getFilesDir()+ "/browser3.db";
        /*SQLiteOpenHelper dbhelper = new SQLiteOpenHelper(getApplicationContext(),"browser.db",null,1) {
            @Override
            public void onCreate(SQLiteDatabase sqLiteDatabase) {

            }

            @Override
            public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) {

            }

            public void onOpen(SQLiteDatabase db)
            {

            }
        };*/
        //File export = new File(this.getFilesDir().getAbsolutePath()+"/bookmarks.csv");
        //dbfile_orig = "/data/data/org.mozilla.firefox_beta/files/mozilla/0aekm8mk.default/browser.db";
        ArrayList<Bookmark> bmarkList = new ArrayList<Bookmark>();
        Bookmark root = null;
        try
        {
            File f = new File(dbfile);
            if(!f.exists())
                return null;
            //DBHelper dbhelper = new DBHelper(getApplicationContext());
            //if(!dbhelper.openDataBase())
                //return null;
            //SQLiteDatabase db = dbhelper.getReadableDatabase();
            SQLiteDatabase db = SQLiteDatabase.openDatabase(dbfile,null, SQLiteDatabase.OPEN_READONLY);
            Cursor c = db.rawQuery("SELECT _id,title,url,type,parent  FROM bookmarks WHERE not deleted = 1 ORDER BY created",null);
            //Cursor c = dbhelper.getCursor();
            while(c.moveToNext())
            {
                String url = c.getString(2), title = c.getString(1);
                int id = c.getInt(0), parent = c.getInt(4), type = c.getInt(3);

                Bookmark b = new Bookmark(id,title,url,type,parent);
                if(b.id == 0)
                    root = b;
                bmarkList.add(b);
            }
            c.close();
            db.close();
        }
        catch (Exception sqlEx)
        {
            Log.e("SQLException", sqlEx.getMessage());
            return null;
        }

        ArrayList<ListAdapter> bmarkLists = new ArrayList<ListAdapter>();
        processBookmarks(bmarkLists,bmarkList,root);

        return bmarkLists;
    }

    private void processBookmarks(ArrayList<ListAdapter> lists, ArrayList<Bookmark> bmarkList, Bookmark parent)
    {
        ListIterator<Bookmark> iter = bmarkList.listIterator();

        ArrayList<Bookmark> list = new ArrayList<Bookmark>();

        if(parent.id != 0)
        {
            Bookmark b = new Bookmark(parent.parent,"...","",0,parent.id);
            list.add(b);
        }

        while(iter.hasNext())
        {
            Bookmark b = iter.next();
            if(b.type == 0) {
                boolean proc = false;
                ListIterator<ListAdapter> liter = lists.listIterator();
                while (liter.hasNext())
                {
                    ListAdapter l = liter.next();
                    if (l.parent == b.id)
                        proc = true;
                }
                if(b.selected)
                    proc = true;
                if(!proc)
                {
                    bmarkList.get(bmarkList.indexOf(b)).select();
                    processBookmarks(lists,bmarkList,b);
                }
            }

            if(b.parent == parent.id)
                list.add(b);
        }
        ListAdapter listAdapter = new ListAdapter(this,R.layout.bookmark_info,list);
        listAdapter.parent = parent.id;
        listAdapter.name = parent.getTitle();
        lists.add(listAdapter);
    }

    private void displayListView(ListAdapter dataAdapter)
    {
        //ArrayList<Bookmark> bmarkList = new ArrayList<Bookmark>();
        //Bookmark bmark = new Bookmark(Uri.parse("http://u1"));
        //bmarkList.add(bmark);
        //bmark = new Bookmark(Uri.parse("http://u2"));
        //bmarkList.add(bmark);
        //bmark = new Bookmark(Uri.parse("http://u3"));
        //bmarkList.add(bmark);

        ListView listView = (ListView) findViewById(R.id.listView);
        listView.setAdapter(dataAdapter);


        listView.setOnItemClickListener(new AdapterView.OnItemClickListener()
        {
            public void onItemClick(AdapterView<?> parent, View view, int position, long id)
            {
                Bookmark bmark = (Bookmark) parent.getItemAtPosition(position);
                Toast.makeText(getApplicationContext(),"Clicked on Row: " + bmark.getUrl(), Toast.LENGTH_LONG).show();
                if(bmark.type == 0)
                {
                    setViewList(bmark);
                }
            }
        });

    }

    public void setViewList(Bookmark bookmark)
    {
        ListIterator<ListAdapter> iter = bmarkLists.listIterator();
        while(iter.hasNext())
        {
            ListAdapter l = iter.next();
            if(l.parent == bookmark.id)
                displayListView(l);
        }
    }

    public void getFile(View view)
    {
        ListView listView = (ListView) findViewById(R.id.listView);
        ListAdapter la = (ListAdapter) listView.getAdapter();
        ArrayList<Bookmark> blist = la.bmarkList;
        ListIterator<Bookmark> iter = blist.listIterator();

        ArrayList<Bookmark> del = new ArrayList<>();

        DownloadManager dmgr = (DownloadManager) getSystemService(Context.DOWNLOAD_SERVICE);
        String url, path;
        File ddir, dfile;

        while(iter.hasNext())
        {
            Bookmark b = iter.next();
            if(b.isSelected() && b.type != 0)
            {
                url = b.getUrl();
                ddir = new File(extStor);
                if(!ddir.exists())
                    ddir.mkdirs();
                path =  extStor + "/" + Uri.parse(url).getLastPathSegment();

                if(downloadFile(url,path))
                    if(deleteAfterDl)
                        del.add(b);
            }

        }

        if(deleteAfterDl)
            deleteList(la.bmarkList,del);
        displayListView(la);

        StringBuffer responseText = new StringBuffer();
        responseText.append("The following were selected...\n");

        for(int i=0;i<blist.size();i++)
        {
            Bookmark bmark = blist.get(i);
            if(bmark.isSelected())
            {
                responseText.append("\n" + bmark.getUrl());
            }
        }

        //Toast.makeText(getApplicationContext(), responseText, Toast.LENGTH_LONG).show();
    }

    public boolean downloadFile(String sUrl, String dpath)
    {
        InputStream input = null;
        OutputStream output = null;
        HttpURLConnection connection = null;
        try {
            URL url = new URL(sUrl);
            connection = (HttpURLConnection) url.openConnection();
            connection.connect();

            if (connection.getResponseCode() != HttpURLConnection.HTTP_OK)
            {
                //return "Server returned HTTP " + connection.getResponseCode() + " " + connection.getResponseMessage();
                return false;
            }

            // this will be useful to display download percentage
            // might be -1: server did not report the length
            int fileLength = connection.getContentLength();

            input = connection.getInputStream();
            output = new FileOutputStream(dpath);

            byte data[] = new byte[4096];
            long total = 0;
            int count;
            while ((count = input.read(data)) != -1) {
                // allow canceling with back button
                /*if (isCancelled()) {
                    input.close();
                    return null;
                }*/
                total += count;
                //if (fileLength > 0) // only if total length is known
                //    publishProgress((int) (total * 100 / fileLength));
                output.write(data, 0, count);
            }
        } catch (Exception e) {
            return false;
        } finally {
            try {
                if (output != null)
                    output.close();
                if (input != null)
                    input.close();
            } catch (IOException ignored) {
            }

            if (connection != null)
                connection.disconnect();
        }
        return true;
    }

    public void selectAllNone(View view)
    {
        ListView listView = (ListView) findViewById(R.id.listView);
        ListAdapter la = (ListAdapter) listView.getAdapter();
        ArrayList<Bookmark> blist = la.bmarkList;
        ListIterator<Bookmark> iter = blist.listIterator();

        boolean all = false;
        if(((ToggleButton)view).isChecked())
            all = true;

        while(iter.hasNext())
        {
            if(all)
                iter.next().select();
            else
                iter.next().deselect();
        }
        displayListView(la);
    }

    public void deleteBookmarks(View view)
    {
        ListView listView = (ListView) findViewById(R.id.listView);
        ListAdapter la = (ListAdapter) listView.getAdapter();
        ArrayList<Bookmark> blist = la.bmarkList;
        ListIterator<Bookmark> iter = blist.listIterator();
        ArrayList<Bookmark> del = new ArrayList<>();

        while(iter.hasNext())
        {
            Bookmark b = iter.next();
            if(b.isSelected())
            {
                del.add(b);
            }
        }

        deleteList(la.bmarkList,del);
        //saveBookmarksDB();
        displayListView(la);
    }

    public void deleteList(ArrayList<Bookmark> list, ArrayList<Bookmark> del)
    {
        SQLiteDatabase db = SQLiteDatabase.openDatabase(dbfile,null, SQLiteDatabase.OPEN_READWRITE);
        ListIterator<Bookmark> iter = del.listIterator();
        while(iter.hasNext())
        {
            Bookmark b = iter.next();
            ListIterator<Bookmark> liter = list.listIterator();
            while(liter.hasNext())
            {
                if(liter.next().id == b.id)
                {
                    liter.remove();
                    try
                    {
                        //db.rawQuery("DELETE FROM bookmarks WHERE _id = ?",new String[]{String.valueOf(b.getId())});
                        db.delete("bookmarks","_id = ?",new String[]{Integer.toString(b.getId())});
                    }
                    catch(Exception ex)
                    {
                        Log.e("SQLException", ex.getMessage());
                    }
                }
            }

        }
    }

    public void saveBookmarksDB()
    {
        Process p = null;
        try {
            p = Runtime.getRuntime().exec("su -c cat "+ dbfile + " > " + dbfile_orig);
            p.waitFor();
            p = Runtime.getRuntime().exec("su -c chmod 660 " + dbfile_orig);
            p.waitFor();
            p = Runtime.getRuntime().exec("su -c chown 10143 " + dbfile_orig);
            p.waitFor();
            p = Runtime.getRuntime().exec("su -c chgrp 10143 " + dbfile_orig);
            p.waitFor();
            p = Runtime.getRuntime().exec("su -c restorecon " + dbfile_orig);
            p.waitFor();
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }

    public class Bookmark
    {
        int id, parent, type;
        String title, url;
        Uri uri;
        boolean selected;

        public Bookmark(int i, String t, String u, int ty, int p)
        {
            id = i;
            parent = p;
            title = t;
            type = ty;
            url = u;
            selected = false;
        }

        public Uri getUri()
        {
            return uri;
        }

        public String getUrl()
        {
            return url;
        }

        public String getTitle()
        {
            return title;
        }

        public int getId()
        {
            return id;
        }

        public int getParent()
        {
            return parent;
        }

        public int getType() {return type;}

        public void setUri(Uri u)
        {
            uri = u;
        }

        public boolean isSelected()
        {
            return selected;
        }

        public void select()
        {
            selected = true;
        }

        public void deselect()
        {
            selected = false;
        }

    }

    private class ListAdapter extends ArrayAdapter<Bookmark>
    {
        private ArrayList<Bookmark> bmarkList;
        public int parent;
        public String name;

        public ListAdapter(Context context, int textViewResourceId, ArrayList<Bookmark> bmarkList)
        {
            super(context,textViewResourceId,bmarkList);
            this.bmarkList = new ArrayList<Bookmark>();
            this.bmarkList.addAll(bmarkList);
        }

        private class ViewHolder
        {
            TextView url;
            CheckBox name;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent)
        {

            ViewHolder holder = null;
            Log.v("ConvertView", String.valueOf(position));

            if (convertView == null) {
                LayoutInflater vi = (LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
                convertView = vi.inflate(R.layout.bookmark_info, null);

                holder = new ViewHolder();
                holder.url = (TextView) convertView.findViewById(R.id.url);
                holder.name = (CheckBox) convertView.findViewById(R.id.checkBox1);
                convertView.setTag(holder);

                holder.name.setOnClickListener( new View.OnClickListener()
                {
                    public void onClick(View v)
                    {
                        CheckBox cb = (CheckBox) v ;
                        Bookmark bmark = (Bookmark) cb.getTag();
                        Toast.makeText(getApplicationContext(),
                                "Clicked on Checkbox: " + cb.getText() +
                                        " is " + cb.isChecked(),
                                Toast.LENGTH_LONG).show();
                        if(cb.isChecked())
                            bmark.select();
                        else
                            bmark.deselect();
                    }
                });
            }
            else
            {
                holder = (ViewHolder) convertView.getTag();
            }

            Bookmark bmark = bmarkList.get(position);
            if(bmark.type != 0)
                holder.url.setText(" (" +  bmark.getUrl() + ")");
            holder.name.setText(bmark.getTitle());
            holder.name.setChecked(bmark.isSelected());
            holder.name.setTag(bmark);

            return convertView;
        }

        private void checkButtonClick()
        {
            Button myButton = (Button) findViewById(R.id.buttonGo);
            myButton.setOnClickListener(new View.OnClickListener()
            {

                @Override
                public void onClick(View v)
                {
                }
            });

        }

    }
}

class DBHelper extends SQLiteOpenHelper
{
    private static String TAG = "DataBaseHelper"; // Tag just for the LogCat window
    //destination path (location) of our database on device
    private static String DB_PATH = "";
    private static String DB_NAME ="browser.db";// Database name
    private SQLiteDatabase mDataBase;
    private final Context mContext;

    public DBHelper(Context context)
    {
        super(context, DB_NAME, null, 1);// 1? Its database Version
        if(android.os.Build.VERSION.SDK_INT >= 17){
            DB_PATH = context.getApplicationInfo().dataDir + "/databases/";
        }
        else
        {
            DB_PATH = "/data/data/" + context.getPackageName() + "/databases/";
        }
        this.mContext = context;
    }

    @Override
    public void onCreate(SQLiteDatabase sqLiteDatabase) {

    }

    @Override
    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) {

    }

    public void onOpen(SQLiteDatabase db)
    {

    }

    public void createDataBase() throws IOException
    {
        //If the database does not exist, copy it from the assets.

        boolean mDataBaseExist = checkDataBase();
        if(!mDataBaseExist)
        {
            this.getReadableDatabase();
            this.close();
            try
            {
                //Copy the database from assests
                copyDataBase();
                Log.e(TAG, "createDatabase database created");
            }
            catch (IOException mIOException)
            {
                throw new Error("ErrorCopyingDataBase");
            }
        }
    }

    //Check that the database exists here: /data/data/your package/databases/Da Name
    private boolean checkDataBase()
    {
        File dbFile = new File(DB_PATH + DB_NAME);
        //Log.v("dbFile", dbFile + "   "+ dbFile.exists());
        return dbFile.exists();
    }

    //Copy the database from assets
    private void copyDataBase() throws IOException
    {
        InputStream mInput = mContext.getAssets().open(DB_NAME);
        String outFileName = DB_PATH + DB_NAME;
        OutputStream mOutput = new FileOutputStream(outFileName);
        byte[] mBuffer = new byte[1024];
        int mLength;
        while ((mLength = mInput.read(mBuffer))>0)
        {
            mOutput.write(mBuffer, 0, mLength);
        }
        mOutput.flush();
        mOutput.close();
        mInput.close();
    }

    //Open the database, so we can query it
    public boolean openDataBase() throws SQLException
    {
        String mPath = DB_PATH + DB_NAME;
        //Log.v("mPath", mPath);
        mDataBase = SQLiteDatabase.openDatabase(mPath, null, SQLiteDatabase.OPEN_READWRITE);
        //mDataBase = SQLiteDatabase.openDatabase(mPath, null, SQLiteDatabase.NO_LOCALIZED_COLLATORS);
        return mDataBase != null;
    }

    public Cursor getCursor()
    {
        Cursor c = mDataBase.rawQuery("SELECT url FROM bookmarks",null);
        return c;
    }

    @Override
    public synchronized void close()
    {
        if(mDataBase != null)
            mDataBase.close();
        super.close();
    }
}
